# C++ STL 容器學習指南

C++ 標準模板庫（STL）提供了豐富的容器類型，主要分為以下幾類：

1. **順序容器**：`std::vector`, `std::deque`, `std::list`。
2. **關聯容器**：`std::set`, `std::map`, `std::multiset`, `std::multimap`。
3. **無序關聯容器**：`std::unordered_set`, `std::unordered_map`, `std::unordered_multiset`, `std::unordered_multimap`。
4. **容器適配器**：`std::stack`, `std::queue`, `std::priority_queue`。

以下將依次介紹這些容器的基本特性、常見操作以及使用範例。

---

## 1. 順序容器

順序容器用於存儲和管理一系列按照插入順序排列的元素。這類容器的主要特點是：

- **元素順序**：元素的順序與插入順序一致。
- **操作特性**：根據容器的類型，支持快速的插入、刪除或訪問操作。
- **用途**：適合需要保持元素插入順序或頻繁操作元素的場景。

### **1.1 std::vector**

#### **特性**

- 動態數組，支持隨機訪問。
- 自動調整大小，支持高效的尾部操作。

#### **結構圖解**

`std::vector` 的內部結構類似於一個動態數組，內存是連續的，可以根據需要自動擴展。

```
+----+----+----+----+----+
| 10 | 20 | 30 | 40 |    |  <- 連續內存區
+----+----+----+----+----+
 ^
 起始地址
```

- **特點**:
  1. 所有元素存儲在連續內存中。
  2. 當內存空間不足時，會重新分配更大的內存並拷貝原有數據。
  3. 因為連續內存結構，支持*高效的隨機訪問*。

#### **常見操作**

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4};

    vec.push_back(5);          // 添加 5
    vec.pop_back();            // 移除最後一個元素
    vec.insert(vec.begin(), 0); // 在開頭插入 0
    vec.erase(vec.begin() + 1); // 移除索引 1 的元素

    for (int v : vec) {
        std::cout << v << " ";
    }
    return 0;
}
```

#### **適用場景**

- 須隨機訪問的情況。
- 須頻繁進行尾部操作的情況。

---

### **1.2 std::deque**

#### **特性**

- 雙端隊列，支持高效的頭尾操作, 作為stack跟queue的底層實作效率較高。
- 隨機訪問效率不如 `std::vector`。

#### **結構圖解**

`std::deque` 的內部由多個固定大小的內存塊組成，支持雙端操作。

```
+----+----+    +----+----+
| 10 | 20 | -> | 30 | 40 |
+----+----+    +----+----+
 ^                ^
 頭部             尾部
```

- **特點**:
  1. 元素不保證存儲在連續的內存中。
  2. 支持高效的頭尾操作。
  3. 隨機訪問效率低於 `std::vector`。

#### **常見操作**

```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> dq = {1, 2, 3};

    dq.push_front(0);          // 添加到頭部
    dq.push_back(4);           // 添加到尾部
    dq.pop_front();            // 移除頭部元素
    dq.pop_back();             // 移除尾部元素

    for (int v : dq) {         // 遍歷
        std::cout << v << " ";
    }
    return 0;
}
```

#### **適用場景**

- 須高效進行頭尾操作的情況。

---

### **1.3 std::list**

#### **特性**

- 雙向鏈表，支持高效的插入與刪除操作。
- 不支持隨機訪問。

#### **結構圖解**

`std::list` 的內部是一個雙向鏈表，節點之間通過指針連接。

```
HEAD -> [10] <-> [20] <-> [30] <- TAIL
```

- **特點**:
  1. 插入與刪除操作效率高。
  2. 不支持隨機訪問。

#### **常見操作**

```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};

    lst.push_front(0);         // 添加到頭部
    lst.push_back(4);          // 添加到尾部
    lst.pop_front();           // 移除頭部元素
    lst.pop_back();            // 移除尾部元素

    for (int v : lst) {        // 遍歷
        std::cout << v << " ";
    }
    return 0;
}
```

#### **適用場景**

- 須頻繁在中間進行插入與刪除的情況。

---

## 2. 關聯容器

關聯容器用於高效存儲和查找數據，數據通過鍵值對進行存儲和管理。這類容器的主要特點是：

- **數據管理方式**：元素以鍵值對形式存儲，鍵用於快速查找。
- **自動排序**：有序關聯容器中的元素按照鍵自動排序。
- **操作效率**：查找、插入和刪除操作的時間複雜度為 O(log n)。
- **用途**：適合需要快速查找、按鍵排序或範圍查詢的場景。

### **2.1 std::set**

#### **特性**

- 有序集合，內部元素唯一且自動排序。
- 基於平衡二叉樹實現，查找效率為 O(log n)。

#### **結構圖解**

`std::set` 的內部是平衡二叉樹，節點根據鍵自動排序。

```
       [20]
      /    \
   [10]    [30]
```

- **特點**:
  1. 元素自動排序。
  2. 不允許重複元素。

#### **常見操作**

```cpp
#include <set>
#include <iostream>

int main() {
    std::set<int> s = {3, 1, 4, 1, 2}; // 自動去重並排序

    s.insert(5);                      // 插入元素
    s.erase(3);                       // 移除元素

    for (int v : s) {                 // 遍歷
        std::cout << v << " ";
    }
    return 0;
}
```

#### **適用場景**

- 需要快速檢查元素是否存在，且元素需要有序。

---

### **2.2 std::map**

#### **特性**

- 有序鍵值對，基於平衡二叉樹實現。
- 鍵唯一，並自動排序。

#### **結構圖解**

`std::map` 的內部結構與 `std::set` 類似，但每個節點包含鍵值對。

```
        [20: "b"]
      /          \
 [10: "a"]    [30: "c"]
```

- **特點**:
  1. 按鍵排序。
  2. 鍵值對存儲。

#### **常見操作**

```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> m = {{1, "one"}, {2, "two"}};

    m[3] = "three";                 // 插入鍵值對
    m.erase(1);                      // 刪除鍵

    for (const auto& [key, value] : m) {
        std::cout << key << ": " << value << std::endl;
    }
    return 0;
}
```

#### **適用場景**

- 需要按鍵排序，並快速查找鍵值對。

---

後續部分將包括無序容器（`std::unordered_set`, `std::unordered_map`）及容器適配器的詳細介紹。如果需要具體的容器功能或進階用法說明，可以進一步補充！
